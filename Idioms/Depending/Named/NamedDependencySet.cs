using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Decoratid.Extensions;

namespace Decoratid.Idioms.Depending.Named
{
    /// <summary>
    /// A container of nameddependencies and object instances associated with each named dependency. Helper methods
    /// exist to create NamedDependencySet by examination of types' NamedDependencyAttribute, facilitating
    /// auto-discovery of dependencies (and associated instances) by type metadata.
    /// </summary>
    public class NamedDependencySet
    {
        #region Inner Classes
        /// <summary>
        /// a named dependency that is associated with an object instance.
        /// </summary>
        public class NamedDependencyWithObjectInstance : NamedDependency
        {
            #region Ctor
            public NamedDependencyWithObjectInstance(object instance, NamedDependency dependency)
                : base()
            {
                this.Instance = instance;

                if (dependency == null)
                {
                    this.Self = Guid.NewGuid().ToString();
                    this.IsKeyAutogenerated = true;
                }
                else
                {
                    this.IsKeyAutogenerated = false;

                    this.Classification = dependency.Classification;
                    this.Self = dependency.Self;
                    this.Prerequisites = dependency.Prerequisites;
                }
            }
            #endregion

            #region Properties
            public bool IsKeyAutogenerated { get; private set; }
            public object Instance { get; private set; }
            #endregion

            #region Calculated Properties
            public bool HasNoDependency
            {
                get
                {
                    if (this.IsKeyAutogenerated ) { return true; }
                    if (this.Prerequisites == null || this.Prerequisites.Count == 0) { return true; }
                    return false;
                }
            }
            #endregion

            #region Methods
            public T GetInstance<T>()
            {
                return (T)this.Instance;
            }
            #endregion
        }
        #endregion

        #region Declarations
        private readonly object _stateLock = new object();
        #endregion

        #region Ctor
        public NamedDependencySet()
        {
            this.Items = new List<NamedDependencyWithObjectInstance>();
        }
        #endregion

        #region Properties
        private List<NamedDependencyWithObjectInstance> Items { get; set; }
        #endregion

        #region Methods
        /// <summary>
        /// adds a dependency item. will not add if item with the same "Self" already exists.
        /// </summary>
        /// <param name="instance"></param>
        /// <param name="dependency"></param>
        public bool AddDependency(object instance, NamedDependency dependency)
        {
            NamedDependencyWithObjectInstance item = new NamedDependencyWithObjectInstance(instance, dependency);

            lock (this._stateLock)
            {
                if (!this.Items.Exists(x => x.Self == item.Self))
                {
                    this.Items.Add(item);
                    return true;
                }
            }
            return false;
        }
        public bool RemoveDependency(string dependencyName)
        {
            lock (this._stateLock)
            {
                if (this.Items.Exists(x => x.Self == dependencyName))
                {
                    var item = this.Items.Find(x => x.Self == dependencyName);
                    this.Items.Remove(item);
                    return true;
                }
            }
            return false;
        }
        /// <summary>
        /// for all the contained dependencies, sorts and returns them
        /// </summary>
        /// <returns></returns>
        public List<NamedDependencyWithObjectInstance> GetTotalDependencyOrder()
        {
            var castedList = this.Items.Cast<NamedDependency>().ToList();
            List<NamedDependency> list = NamedDependency.Sort(castedList);
            return list.Cast<NamedDependencyWithObjectInstance>().ToList();
        }
        /// <summary>
        /// for the given dependency, gets its tree, sorted from least dependent to most
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public List<NamedDependencyWithObjectInstance> GetDependencyTree(NamedDependencyWithObjectInstance item)
        {
            var castedList = this.Items.Cast<NamedDependency>().ToList();
            var list = NamedDependency.GetSortedDependencies(castedList, item);
            return list.Cast<NamedDependencyWithObjectInstance>().ToList();
        }
        public NamedDependencyWithObjectInstance GetDependencyItem(string dependencyName)
        {
            return this.Items.Find(x => x.Self == dependencyName);
        }
        #endregion

        #region Static Methods
        /// <summary>
        /// creates a set using the supplied types, by examining their NamedDependencyAttribute
        /// </summary>
        /// <param name="types"></param>
        /// <param name="dependencyName"></param>
        /// <returns></returns>
        public static NamedDependencySet BuildSetFromTypeAttributes(List<Type> types, string dependencyName)
        {
            NamedDependencySet set = new NamedDependencySet();

            var list  = NamedDependencyAttribute.GetAttributeAndSort(types, dependencyName);

            list.WithEach(x =>
            {
                var obj = Activator.CreateInstance(x.Item1);
                set.AddDependency(obj, x.Item2);
            });

            return set;
        }
        #endregion
    }
}
