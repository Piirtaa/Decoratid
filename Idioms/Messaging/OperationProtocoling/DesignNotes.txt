The operation protocol sits on top of the store protocol.  It's an agreement on how the request payload (ie. IStore) 
is to be interpreted, handled, and on how the results will be saved to the response store.

An Operation is 

Each end point has a set of handlers, each of which corresponds to a message type that can be handled.
Each message type is uniquely identified by a key, which also id's the Request's payload, and id's the handler.
Handlers respond by writing entries in {Key}_Response.

In other words, handler (Id="A") examines the request store @ (Id="A"), and if an entry exists, it responds @ Id="A_Response"
on the response store.

All handlers on an endpoint will touch the request store in this way.

The standard protocol has some reserved keys/handlers.
	-Id => returns the server's Id
	-Version => returns the server's Version
	-Async => request provides ConnectionString and Id for the response.  
	-
		{Key}_Response - for the response
		{Key}_ResponseError - for detailed error info
		{Key}_ResponseHandlerVersion - for version info on the handler
	-Keys => returns the handled keys on the end point 

Handlers are sorted by dependency prior to execution.

    /*Endpoint logic is the logic that gets executed at an endpoint when a string request gets sent to it, producing a string result.  
* String being the lingua franca for data exchange.
* 
* Store Protocol:
* Instead of string, we exchange IStores.  To implement this change we have StoreProtocolLogic (instance of IEndPointLogic)
* that converts messages to store, and provides interception via IStoreProtocolHandler.  IStoreProtocolHandlers registered 
* at the Host are all executed against the Request/Response.  
*  -The handler chain enables discretization of commands within the request store.  That is, each handler can inspect the
*  request/response stores and pull out the data they need.  Also, with discrete commands comes batching and workflow.
* 
* Store of Operations Protocol:
* Where the store protocol says we're passing stores, and leaves it up to the handlers to do what work they want, the
* Store of Operations Protocol sits on top of this, too, and further constrains the form of the data being used.
* 
*  Operation - IHasId<string>, IHasDependencyOf<Operation>
*      RemoteRequest - StoredObjectPointer
*      Request
*      Error
*      Response
*      RemoteResponse - StoredObjectPointer
*  
*  The response store is a hydrated version of the request store.
*  
*  To send a discrete operation the sig would look like this
*      Send(string operation, object request data, StoredObjectPointer remote response)
*      Send(string operation, StoredObjectPointer remote request, StoredObjectPointer response)
* 
*  or batch calls.
*     AddToBatch(string operation, ....) as above
*      -fluent operation store methods   
*  
* 
*/